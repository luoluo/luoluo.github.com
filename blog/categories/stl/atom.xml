<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: STL | lf2012]]></title>
  <link href="http://luoluo.github.com/blog/categories/stl/atom.xml" rel="self"/>
  <link href="http://luoluo.github.com/"/>
  <updated>2013-02-28T18:10:29+08:00</updated>
  <id>http://luoluo.github.com/</id>
  <author>
    <name><![CDATA[Luoluo]]></name>
    <email><![CDATA[luoluo1920@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sort]]></title>
    <link href="http://luoluo.github.com/blog/2012/05/12/sort"/>
    <updated>2012-05-12T13:44:00+08:00</updated>
    <id>http://luoluo.github.com/blog/2012/05/12/sort</id>
    <content type="html"><![CDATA[<h4 id='stl'>STL中最常用的函数之一，排序的神器。</h4>

<h3 id='sort'>sort</h3>

<p>{% codeblock function sort.cpp %} <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;algorithm&gt;
template &lt;class RandomAccessIterator&gt;
  void sort ( RandomAccessIterator first, RandomAccessIterator last );</pre></p>

<p>template <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;class RandomAccessIterator, class Compare&gt;
  void sort ( RandomAccessIterator first, RandomAccessIterator last, Compare comp );
{% endcodeblock %}</pre></p>

<h3 id='function'>function</h3>

<blockquote>
<p>Sort elements in range Sorts the elements in the range <span>first,last) into ascending order.</span></p>

<p>The elements are compared using operator&lt; for the first version, and comp for the second.</p>

<p>Elements that would compare equal to each other are not guaranteed to keep their original relative order.</p>
</blockquote>

<h3 id='parameters'>Parameters</h3>

<blockquote>
<p>first, last Random-Access iterators to the initial and final positions of the sequence to be sorted. The range used is <span>first,last), which contains all the elements between first and last, including the element pointed by first but not the element pointed by last. comp Comparison function object that, taking two values of the same type than those contained in the range, returns true if the first argument goes before the second argument in the specific strict weak ordering it defines, and false otherwise.</span></p>
</blockquote>

<h3 id='return_value'>Return value</h3>

<blockquote>
<p>none</p>
</blockquote>

<h3 id='example'>Example</h3>

<p>{% codeblock example.cpp%} // sort algorithm example</p>

<h1 id='include_'>include <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;iostream&gt;</pre></h1>

<h1 id='include_'>include <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;algorithm&gt;</pre></h1>

<h1 id='include_'>include <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;vector&gt;</pre></h1>

<p>using namespace std;</p>

<p>bool myfunction (int i,int j) { return (i</p>

<p>struct myclass { bool operator() (int i,int j) { return (i</p>

<p>int main () { int myints<span /> = {32,71,12,45,26,80,53,33}; vector<pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;int&gt; myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33
  vector&lt;int&gt;::iterator it;</pre></p>

<p>// using default comparison (operator &lt;): sort (myvector.begin(), myvector.begin()+4); //(12 32 45 71)26 80 53 33</p>

<p>// using function as comp sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)</p>

<p>// using object as comp sort (myvector.begin(), myvector.end(), myobject); //(12 26 32 33 45 53 71 80)</p>

<p>// print out content: cout &#171;&#160;&#8220;myvector contains:&#8221;; for (it=myvector.begin(); it!=myvector.end(); ++it) cout &#171;&#160;&#8221; &#8221; &#171;&#160;<em>it;</em></p>

<p>cout &#171;&#160;endl;</p>

<p>return 0; } {% endcodeblock %}</p>

<h3 id='output'>Output:</h3>

<blockquote>
<p>myvector contains: 12 26 32 33 45 53 71 80</p>
</blockquote>

<h3 id='complexity'>Complexity</h3>

<blockquote>
<p>Approximately N<em>logN comparisons on average (where N is last-first). In the worst case, up to N2, depending on specific sorting algorithm used by library implementation.</em></p>
</blockquote>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next Permutation]]></title>
    <link href="http://luoluo.github.com/blog/2012/05/09/next-permutation"/>
    <updated>2012-05-09T22:06:00+08:00</updated>
    <id>http://luoluo.github.com/blog/2012/05/09/next-permutation</id>
    <content type="html"><![CDATA[<h3 id='tc'>做TC练习的时候，学习高手的代码，看到了这个神器。用于生成不重复的且不小于当前排列的全排列。</h3>

<h2 id='next_permutation'>next_permutation</h2>

<p>{% codeblock function fun.cpp %} template <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;class BidirectionalIterator&gt;
  bool next_permutation (BidirectionalIterator first,
                         BidirectionalIterator last );</pre></p>

<p>template <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;class BidirectionalIterator, class Compare&gt;
  bool next_permutation (BidirectionalIterator first,
                         BidirectionalIterator last, Compare comp);
{% endcodeblock %}</pre></p>

<h3 id='transform_range_to_next_permutation'>Transform range to next permutation</h3>

<blockquote>
<p>Rearranges the elements in the range <span>first, last) into the lexicographically next greater permutation of elements. The comparisons of individual elements are performed using either operator&lt; for the first version, or comp for the second.</span></p>
</blockquote>

<blockquote>
<p>A permutation is each one of the N! possible arrangements the elements can take (where N is the number of elements in the range). Different permutations can be ordered according on how they compare lexicographicaly to each other; The first such-sorted possible permutation (the one that would compare lexicographically smaller to all other permutations) is the one which has all its elements sorted in ascending order, and the largest has all its elements sorted in descending order.</p>
</blockquote>

<blockquote>
<p>If the function can determine the next higher permutation, it rearranges the elements as such and returns true. If that was not possible (because it is already at the largest), it rearranges the elements according to the first permutation (sorted in ascending order) and returns false.</p>
</blockquote>

<h3 id='parameters'>Parameters</h3>

<blockquote>
<p>first, last Bidirectional iterators to the initial and final positions of the sequence. The range used is <span>first,last), which contains all the elements between first and last, including the element pointed by first but not the element pointed by last. comp Comparison function object that, taking two values of the same type than those contained in the range, returns true if the first argument is to be considered less than the second argument.</span></p>
</blockquote>

<h3 id='return_value'>Return value</h3>

<blockquote>
<p>true if the function could rearrange the object as a lexicographicaly greater permutation. Otherwise, the function returns false to indicate that the arrangement is not greater than the previous, but the lowest possible (sorted in ascending order).</p>
</blockquote>

<h3 id='example'>Example</h3>

<p>{% codeblock next_permutation tset.cpp %}</p>

<h1 id='include_'>include <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;iostream&gt;</pre></h1>

<h1 id='include_'>include <pre class='markdown-html-error' style='border: solid 3px red; background-color: pink'>REXML could not parse this XML/HTML: 
&lt;algorithm&gt;</pre></h1>

<p>using namespace std;</p>

<p>int main () { int myints<span /> = {1,2,3};</p>

<p>cout &#171;&#160;&#8220;The 3! possible permutations with 3 elements:\n&#8221;;</p>

<p>sort (myints,myints+3);</p>

<p>do { cout &#171;&#160;myints<span>0</span> &#171;&#160;&#8221; &#8221; &#171;&#160;myints<span>1</span> &#171;&#160;&#8221; &#8221; &#171;&#160;myints<span>2</span> &#171;&#160;endl; } while ( next_permutation (myints,myints+3) );</p>

<p>return 0; } {% endcodeblock %}</p>

<h3 id='output'>Output:</h3>

<p>The 3! possible permutations with 3 elements:</p>

<p>1 2 3 <br /> 1 3 2 <br /> 2 1 3 <br /> 2 3 1 <br /> 3 1 2 <br /> 3 2 1 <br /></p>

<h4 id='id26'>注意</h4>

<p>当输出{1, 1, 1}的全排列时只输出一组“1 1 1”；</p>

<h3 id='id27'>上升全排列</h3>

<p><code>int myints[] = {1,2,3};</code> 输出为：<br /> 1 2 3 <br /> 1 3 2 <br /> 2 1 3 <br /> 2 3 1 <br /> 3 1 2 <br /> 3 2 1 <br /></p>

<p><code>int myints[] = {3,2,1};</code> 输出为：<br /> 3 2 1<br /></p>

<p><code>int myints[] = {2,3,1};</code> 输出为：<br /> 2 3 1 <br /> 3 1 2 <br /> 3 2 1 <br /></p>

<h4 id='sort'>所以想得到给定数组元素的全排列，首先要<a href='http://luoluo.github.com/blog/2012/05/12/sort/'>sort</a>为单调上升序列。</h4>

<h3 id='complexity'>Complexity</h3>

<blockquote>
<p>At most, performs one half as many swaps as the number of elements in the range.</p>
</blockquote>]]></content>
  </entry>
  
</feed>
